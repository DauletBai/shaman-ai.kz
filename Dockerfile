# Этап 1: Сборка приложения (Builder Stage)
# Используем официальный образ Golang как основу для сборки.
# Выбираем версию Go, соответствующую вашему проекту (например, 1.22 или новее).
# Alpine-версия образа используется для уменьшения размера промежуточного образа сборщика.
FROM golang:1.22-alpine AS builder

# Устанавливаем рабочую директорию внутри образа
WORKDIR /app

# Копируем файлы управления зависимостями
COPY go.mod go.sum ./

# Загружаем зависимости.
# 'go mod download' загружает зависимости, указанные в go.mod.
# 'go mod verify' проверяет, что зависимости не были изменены с момента их добавления в go.sum.
RUN go mod download && go mod verify

# Копируем весь остальной исходный код проекта в рабочую директорию образа
COPY . .

# Собираем приложение.
# CGO_ENABLED=0 отключает использование Cgo, что позволяет создавать статически связанные бинарники
# и избежать зависимостей от C-библиотек в финальном образе, если они не нужны.
# GOOS=linux GOARCH=amd64 указывают целевую операционную систему и архитектуру (типично для большинства VPS).
# -ldflags="-s -w" убирает отладочную информацию и таблицу символов, уменьшая размер бинарника.
# -o /shaman-ai-server указывает, что скомпилированный бинарник будет называться shaman-ai-server и будет расположен в корне файловой системы образа сборщика.
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o /shaman-ai-server ./cmd/server/main.go

# Этап 2: Создание финального минимального образа (Final Stage)
# Используем легкий базовый образ Alpine Linux для финального образа, чтобы он был как можно меньше.
FROM alpine:latest

# Устанавливаем необходимые пакеты в Alpine.
# ca-certificates нужен для HTTPS-запросов из вашего Go-приложения (например, к LLM API).
# tzdata нужен для корректной работы с часовыми поясами, если ваше приложение это использует.
RUN apk --no-cache add ca-certificates tzdata

# Устанавливаем рабочую директорию в финальном образе
WORKDIR /app

# Копируем скомпилированный бинарный файл из образа сборщика (builder stage)
COPY --from=builder /shaman-ai-server /app/shaman-ai-server

# Копируем необходимые статические ресурсы и шаблоны из образа сборщика
COPY --from=builder /app/static ./static
COPY --from=builder /app/templates ./templates
COPY --from=builder /app/configs ./configs
COPY --from=builder /app/migrations ./migrations
# ВАЖНО: НЕ КОПИРУЙТЕ сюда файлы типа .env или другие чувствительные данные,
# которые должны управляться через переменные окружения!

# Создаем директорию для загружаемых файлов внутри контейнера.
# И меняем владельца на пользователя 'nobody', от имени которого будет запускаться приложение,
# для повышения безопасности (принцип наименьших привилегий).
RUN mkdir -p /app/uploads && chown -R nobody:nogroup /app/uploads

# Указываем, что приложение будет запускаться от имени пользователя 'nobody'
USER nobody:nogroup

# Указываем порт, который приложение будет слушать внутри контейнера.
# Это тот порт, который вы указываете в переменной окружения PORT для вашего приложения.
EXPOSE 8080

# Команда по умолчанию для запуска приложения при старте контейнера.
# Приложение запустится с настройками, переданными через переменные окружения
# (которые будут заданы в docker-compose.yml или при запуске 'docker run').
ENTRYPOINT ["/app/shaman-ai-server"]